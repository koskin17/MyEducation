# Generator function randomWord has as an argument list of words. It should return any random word from this list. Each time words are different until the end of the list is reached. Then words are taken from the initial list again.

# For example if 
# list = ['book', 'apple', 'word']
# books = randomWord(list)
# then possible output example 
# first call of next(books) returns apple
# second call of next(books) returns book
# third call of next(books) returns word
# fourth call of next(books) returns book

# import random
# from random import choice

# list = ['book', 'apple', 'word']

# def randomWord(list):
    
#     used_word = []

#     if list != []:
#         word = random.choice(list)
#         used_word.append(word)
#         list.pop(list.index(word))
#         return word
    
# print(randomWord(list)) # apple
# print(randomWord(list)) # book
# print(randomWord(list)) # word
# print(randomWord(list)) # word

# Ваше решение имеет несколько проблем и не соответствует требованиям задачи. Вот оценка вашего решения и способы его оптимизации (а точнее, его **исправления**):

# **Оценка текущего решения:**

# 1.  **Не является генератором:** Функция `randomWord` использует `return word` вместо `yield word`, поэтому это обычная функция, а не функция-генератор. Она вернет случайное слово только один раз при первом вызове и завершит свою работу. Последующие попытки вызвать `next()` на результате приведут к ошибке `TypeError: 'str' object is not an iterator`.
# 2.  **Модифицирует входной список:** Функция `list.pop(list.index(word))` удаляет выбранное слово из исходного списка. Это нежелательное побочное действие, так как функция не должна изменять входные данные, если это явно не оговорено.
# 3.  **Неправильная логика повторного использования:** Логика с `used_word` и `list.pop()` не обеспечивает циклическое использование слов после того, как список закончится. Функция просто перестанет возвращать слова, когда `list` станет пустым.
# 4.  **Условие `if list != []:` внутри функции:** Это условие проверяется только один раз при первом вызове функции (если бы она была генератором). Для генератора нужно итерироваться по списку циклически.

# **Как исправить и оптимизировать решение:**

# Чтобы решение соответствовало требованиям задачи (быть генератором, возвращать случайные слова без повторений до конца списка, а затем начинать снова), можно использовать следующий подход:

import random

def randomWord(words):
    """
    Генератор, возвращающий случайные слова из списка.
    Слова не повторяются до тех пор, пока не будут использованы все,
    затем выбор начинается снова с перемешанного исходного списка.

    Args:
        words: Список строк (слов).

    Yields:
        Случайное слово из списка.
    """
    if not words:
        return  # Если список пуст, генератор ничего не выдает

    accessible_words = list(words)  # Создаем копию, чтобы не изменять оригинал
    random.shuffle(accessible_words)
    index = 0

    while True:
        if index < len(accessible_words):
            yield accessible_words[index]
            index += 1
        else:
            accessible_words = list(words)  # Создаем новую копию
            random.shuffle(accessible_words)
            index = 0

word_list = ['book', 'apple', 'word']
word_generator = randomWord(word_list)

print(next(word_generator))
print(next(word_generator))
print(next(word_generator))
print(next(word_generator))
print(next(word_generator))
print(next(word_generator))

# **Объяснение исправленного решения:**

# 1.  **Генераторная функция:** Функция `randomWord` теперь использует `yield` для возврата каждого случайного слова, делая её генератором.
# 2.  **Копия списка:** Мы создаем копию входного списка `words` в `accessible_words`, чтобы не изменять исходный список.
# 3.  **Перемешивание:** При первой итерации (и каждый раз, когда все слова были использованы), мы случайным образом перемешиваем `accessible_words` с помощью `random.shuffle()`. Это гарантирует, что порядок слов будет разным при каждом цикле.
# 4.  **Индекс отслеживания:** Мы используем переменную `index` для последовательного перебора перемешанного списка.
# 5.  **Циклическое использование:**
#     * Пока `index` меньше длины `accessible_words`, мы выдаем слово по текущему индексу и увеличиваем `index`.
#     * Когда `index` достигает конца списка, мы создаем новую перемешанную копию исходного списка и сбрасываем `index` на 0, чтобы начать выдавать слова снова.
# 6.  **Обработка пустого списка:** Добавлена проверка на пустой входной список. В этом случае генератор просто завершает работу и не выдает никаких значений.

# **Оптимизация:**

# В данном случае "оптимизация" в основном заключается в написании корректного решения, которое соответствует требованиям. С точки зрения производительности, этот подход достаточно эффективен для небольших и средних списков слов.

# Для очень больших списков можно рассмотреть другие подходы, но для данной задачи предложенное исправленное решение является понятным и эффективным. Оно избегает ненужных операций и обеспечивает требуемое циклическое поведение со случайным порядком слов.

# Для очень больших списков слов предложенное ранее решение с перемешиванием копии списка при каждом цикле может стать неэффективным из-за затрат на создание новой копии и перемешивание. Оптимальным подходом в этом случае будет использование **итератора с циклическим случайным выбором без полного перемешивания на каждой итерации**.

# Вот оптимальное решение для очень больших списков с объяснением:

# import random

# def randomWord_optimized(words):
#     """
#     Оптимизированный генератор для очень больших списков слов.
#     Возвращает случайное слово из списка циклически, избегая полного
#     перемешивания на каждой итерации.

#     Args:
#         words: Список строк (слов).

#     Yields:
#         Случайное слово из списка.
#     """
#     if not words:
#         return

#     n = len(words)
#     indices = list(range(n))
#     random.shuffle(indices)
#     index_pointer = 0

#     while True:
#         if index_pointer < n:
#             yield words[indices[index_pointer]]
#             index_pointer += 1
#         else:
#             random.shuffle(indices)
#             index_pointer = 0

# # Пример использования:
# large_word_list = ['word_' + str(i) for i in range(100000)]  # Большой список
# optimized_generator = randomWord_optimized(large_word_list)

# for _ in range(5):
#     print(next(optimized_generator))

# **Объяснение оптимального решения:**

# 1.  **Использование индексов:** Вместо создания и перемешивания копии самого списка слов на каждой итерации, мы создаем список индексов от 0 до `len(words) - 1`.
# 2.  **Первоначальное перемешивание индексов:** Мы перемешиваем этот список индексов только один раз в начале (или когда все индексы были использованы).
# 3.  **Итерация по перемешанным индексам:** Генератор циклически проходит по перемешанному списку индексов. На каждой итерации он использует текущий индекс для доступа к соответствующему слову в исходном списке `words`.
# 4.  **Повторное перемешивание индексов:** Когда достигается конец списка индексов (`index_pointer == n`), мы снова перемешиваем список индексов и сбрасываем `index_pointer` на 0. Это обеспечивает новый случайный порядок слов для следующего цикла.

# **Преимущества этой оптимизации для больших списков:**

# * **Избегание копирования больших списков:** Мы копируем только список индексов, размер которого значительно меньше, чем сам список слов (особенно если слова длинные).
# * **Редкое перемешивание:** Операция перемешивания `random.shuffle()` выполняется только один раз за цикл всех слов, а не на каждой итерации. Это значительно снижает вычислительные затраты, особенно для очень больших списков.
# * **Сохранение исходного списка:** Исходный список `words` остается неизменным.

# **Почему это оптимальнее:**

# Для больших списков операция копирования и перемешивания всего списка слов может быть дорогостоящей по времени и памяти. Оптимизированный подход работает с массивом целых чисел (индексов), что гораздо эффективнее. Мы лишь единожды перемешиваем этот массив индексов за полный проход по всем словам.

# Таким образом, для сценариев, где список слов очень велик и требуется многократная итерация со случайным порядком, этот метод с использованием перемешанных индексов является значительно более производительным.