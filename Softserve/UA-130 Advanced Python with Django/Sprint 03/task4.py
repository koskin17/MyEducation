# Create function-generator divisor that should return all divisors of the positive number.
# If there are no divisors left function should return None.
# three = divisor(3)
# next(three) => 1
# next(three) => 3
# next(three) => None

def divisor(number):
    """
    Генератор, возвращающий все делители положительного числа.

    Args:
        number: Положительное целое число.

    Yields:
        Каждый делитель числа. Возвращает None после того, как все делители выданы,
        и продолжает возвращать None при последующих вызовах.
    """
    if not isinstance(number, int) or number <= 0:
        raise ValueError("Input must be a positive integer")

    divisors = []
    for i in range(1, number + 1):
        if number % i == 0:
            divisors.append(i)

    index = 0
    while True:
        if index < len(divisors):
            yield divisors[index]
            index += 1
        else:
            yield None

# Тестовый пример (как в вашем запросе):
two = divisor(2)
print(next(two))
print(next(two))
print(next(two))
print(next(two))

# **Подробное объяснение:**

# 1.  **`def divisor(number):`**:
#     * Определяем функцию `divisor`, которая принимает один аргумент `number` (положительное целое число).
#     * Добавлена проверка на то, что входной аргумент является положительным целым числом. Если это не так, выбрасывается исключение `ValueError`. Это делает функцию более надежной.

# 2.  **`if not isinstance(number, int) or number <= 0:`**:
#         * Проверяем, является ли `number` целым числом, и больше ли оно нуля.

# 3.  **`for i in range(1, number + 1):`**:
#     * Начинаем цикл от 1 до `number` включительно.  Переменная `i` будет представлять потенциальные делители.

# 4.  **`if number % i == 0:`**:
#     * Проверяем, является ли `i` делителем `number`.  Если остаток от деления `number` на `i` равен 0, значит, `i` - делитель.

# 5.  **`yield i`**:
#     * Если `i` является делителем, мы используем ключевое слово `yield`, чтобы вернуть его.  Функция `divisor` становится генератором.  Когда вызывается `next(generator)`, генератор выполняет код до первого `yield`, возвращает значение и приостанавливает свое выполнение.  При следующем вызове `next(generator)`, он продолжает с того места, где остановился.

# 6.  **`yield None`**:
#     * После того как цикл завершится (то есть, все делители были найдены), мы выполняем `yield None`.  Это нужно для того, чтобы явно указать, что больше делителей нет, и генератор закончил свою работу.  Без этого, при попытке взять следующий элемент после последнего делителя, было бы вызвано исключение `StopIteration`, что менее удобно в использовании.

# **Как это работает на примере `three = divisor(3)`:**

# 1.  Вызывается `divisor(3)`.  Функция `divisor` становится генератором.  Никакой код внутри функции еще не выполняется.
# 2.  Результат (объект генератора) присваивается переменной `three`.

# **Как это работает на примере `next(three)`:**

# 1.  Вызывается `next(three)`.  Генератор `divisor` начинает выполняться.
# 2.  Цикл начинается с `i = 1`.  `3 % 1 == 0` истинно, поэтому `yield 1`.
# 3.  Значение 1 возвращается, и выполнение генератора приостанавливается.
# 4.  Вызывается `next(three)` еще раз.  Генератор продолжает выполнение с того места, где остановился (сразу после `yield 1`).
# 5.  Цикл продолжается:
#     * `i = 2`.  `3 % 2 == 0` ложно.
#     * `i = 3`.  `3 % 3 == 0` истинно, поэтому `yield 3`.
# 6.  Значение 3 возвращается, и выполнение генератора приостанавливается.
# 7.  Вызывается `next(three)` еще раз.  Генератор продолжает выполнение.
# 8.  Цикл завершается.
# 9.  Выполняется `yield None`.
# 10. Значение `None` возвращается.
# 11. При следующем вызове `next(three)` будет вызвано исключение `StopIteration`, так как генератор завершил свою работу.  Но в нашем коде, мы явно возвращаем None, чтобы избежать исключения.

# Объяснение этого окончательного исправления:

# Мы по-прежнему сначала находим все делители и сохраняем их в списке divisors.
# Мы инициализируем переменную index равной 0 для отслеживания текущего индекса в списке делителей.
# Мы используем бесконечный цикл while True:.
# Внутри цикла мы проверяем, находится ли текущий index в пределах границ списка divisors.
# Если index < len(divisors), мы выдаем (yield) делитель по этому индексу и увеличиваем index на 1.
# Если index достиг конца списка (или превысил его), это означает, что все делители уже были выданы. В этом случае мы выполняем yield None. Поскольку цикл while True: продолжается, при следующем вызове next() снова будет выполнена ветвь else и снова вернется None.
# Теперь генератор будет сначала выдавать все делители по одному, а затем бесконечно возвращать None при последующих вызовах next(), что соответствует вашему ожидаемому поведению.