# Create function create with one string argument. This function should return anonymous function that checks if the argument of function is equals to the argument of outer function. 

# For example: 
#  tom = create("pass_for_Tom") 
#  tom("pass_for_Tom") returns true 
#  tom("pass_for_tom") returns false

def create(outer_arg):
    """
    Создает и возвращает анонимную функцию (lambda-функцию),
    которая проверяет, равен ли её аргумент аргументу внешней функции 'outer_arg'.

    Args:
        outer_arg: Строка, с которой будет сравниваться аргумент анонимной функции.

    Returns:
        Анонимная функция, выполняющая проверку на равенство.
    """
    return lambda inner_arg: inner_arg == outer_arg

# Пример использования:
tom = create("pass_for_Tom")
print(tom("pass_for_Tom"))  # Выводит: True
print(tom("pass_for_tom"))  # Выводит: False

lisa = create("secret_lisa")
print(lisa("secret_lisa")) # Выводит: True
print(lisa("wrong_password")) # Выводит: False

# **Подробное объяснение:**

# 1.  **`def create(outer_arg):`**:
#     * Мы определяем функцию с именем `create`, которая принимает один аргумент `outer_arg`. Это значение, с которым мы будем сравнивать аргумент анонимной функции.

# 2.  **`lambda inner_arg: inner_arg == outer_arg`**:
#     * Внутри функции `create` мы создаем анонимную функцию (lambda-функцию).
#     * `lambda` - это ключевое слово, используемое для создания анонимных функций в Python.
#     * `inner_arg` - это аргумент, который принимает анонимная функция.
#     * `inner_arg == outer_arg` - это выражение, которое вычисляется и возвращается анонимной функцией.  Оно сравнивает аргумент `inner_arg` с `outer_arg` (значением, переданным в `create`) и возвращает `True`, если они равны, и `False` в противном случае.
#     * Важно отметить, что lambda-функция имеет доступ к переменной `outer_arg` из области видимости функции `create`. Это снова пример **замыкания (closure)**.

# 3.  **`return lambda inner_arg: inner_arg == outer_arg`**:
#     * Функция `create` возвращает созданную lambda-функцию.

# **Как это работает на примере `tom = create("pass_for_Tom")`**:

# 1.  Вызывается функция `create` с аргументом `"pass_for_Tom"`.
# 2.  Внутри `create` создается lambda-функция: `lambda inner_arg: inner_arg == "pass_for_Tom"`.
# 3.  Функция `create` возвращает эту lambda-функцию.
# 4.  Возвращенная lambda-функция присваивается переменной `tom`.  Теперь `tom` - это функция, которая проверяет, равен ли её аргумент строке `"pass_for_Tom"`.

# **Как это работает на примере `tom("pass_for_Tom")` и `tom("pass_for_tom")`**:

# 1.  Вызывается функция, на которую ссылается переменная `tom`.  Это lambda-функция, созданная ранее.
# 2.  Аргумент `"pass_for_Tom"` передается в lambda-функцию.
# 3.  Вычисляется выражение `"pass_for_Tom" == "pass_for_Tom"`, которое равно `True`.
# 4.  Возвращается значение `True`.

# Во втором случае, аргумент `"pass_for_tom"` передается в ту же lambda-функцию. Вычисляется выражение `"pass_for_tom" == "pass_for_Tom"`, которое равно `False`, и возвращается `False`.

# Таким образом, функция `create` создает функцию-компаратор, которая "помнит" значение, с которым нужно сравнивать.

# Когда вы вызываете функцию `create`, например:

# ```python
# tom = create("pass_for_Tom")
# ```

# происходит следующее:

# 1.  Функция `create` выполняется с аргументом `"pass_for_Tom"`. Этот аргумент присваивается переменной `outer_arg` внутри функции `create`.
# 2.  Внутри `create` определяется и возвращается анонимная функция (лямбда-функция): `lambda inner_arg: inner_arg == outer_arg`. Важно понимать, что на этот момент лямбда-функция *не вызывается*, а только *создается*.
# 3.  Возвращенная лямбда-функция присваивается переменной `tom`. Теперь переменная `tom` ссылается на эту функцию.

# **Переменная `inner_arg` и её значение:**

# Переменная `inner_arg` является **аргументом** самой лямбда-функции. Она получает свое значение **только тогда, когда вы вызываете функцию, на которую ссылается переменная `tom` (или любая другая переменная, которой была присвоена возвращенная лямбда-функция)**.

# Рассмотрим примеры вызова `tom`:

# ```python
# print(tom("pass_for_Tom"))  # Здесь "pass_for_Tom" передается как аргумент
# print(tom("wrong_password")) # Здесь "wrong_password" передается как аргумент
# ```

# * **В первом случае (`tom("pass_for_Tom")`)**:
#     * Вы вызываете функцию, на которую ссылается `tom`.
#     * Значение `"pass_for_Tom"` передается в эту функцию.
#     * Внутри лямбда-функции этот переданный аргумент присваивается переменной `inner_arg`.
#     * Затем выполняется сравнение `inner_arg == outer_arg`, то есть `"pass_for_Tom" == "pass_for_Tom"`, что возвращает `True`.

# * **Во втором случае (`tom("wrong_password")`)**:
#     * Вы снова вызываете ту же самую функцию, на которую ссылается `tom`.
#     * Значение `"wrong_password"` передается в эту функцию.
#     * Внутри лямбда-функции этот переданный аргумент присваивается переменной `inner_arg`.
#     * Выполняется сравнение `inner_arg == outer_arg`, то есть `"wrong_password" == "pass_for_Tom"`, что возвращает `False`.

# **Откуда берется значение `inner_arg`:**

# Значение `inner_arg` берется непосредственно из **аргумента, который вы передаете при вызове возвращенной лямбда-функции**.

# **Замыкание (Closure):**

# Важно еще раз подчеркнуть механизм **замыкания**. Когда функция `create` возвращает лямбда-функцию, эта лямбда-функция "помнит" значение переменной `outer_arg` из лексического окружения функции `create`. Даже после того, как функция `create` завершила свое выполнение, возвращенная лямбда-функция сохраняет доступ к этому значению `outer_arg`.

# Таким образом:

# * `outer_arg` получает значение при вызове `create`.
# * `inner_arg` получает значение при последующем вызове лямбда-функции, возвращенной `create`.
# * Лямбда-функция использует "запомненное" значение `outer_arg` для сравнения с `inner_arg`.

# **Шаг 1: Вызов функции `create`**

# Представьте, что у нас есть коробка с названием `create`. Эта коробка умеет принимать одну вещь внутрь себя, и мы эту вещь называем `outer_arg`.

# Когда мы пишем `tom = create("pass_for_Tom")`, мы берем бумажку со словом `"pass_for_Tom"` и кладем её внутрь коробки `create`. Внутри коробки `create` эта бумажка временно называется `outer_arg`.

# **Шаг 2: Что делает коробка `create`?**

# Внутри коробки `create` есть волшебный аппарат, который создает *другую* маленькую коробочку. Эта маленькая коробочка особенная - она умеет принимать одну вещь внутрь себя, и мы эту вещь назовем `inner_arg`.

# Еще эта маленькая коробочка внутри себя имеет инструкцию: "Сравни то, что ты получил (`inner_arg`), с той бумажкой, которую запомнила большая коробка (`outer_arg`). Если они одинаковые, выдай 'Правда', иначе выдай 'Неправда'".

# Сама большая коробка `create` не запускает эту маленькую коробочку. Вместо этого она берет эту маленькую коробочку и отдает её нам. Мы эту маленькую коробочку называем `tom`.

# **Шаг 3: Вызов маленькой коробочки `tom`**

# Теперь у нас есть коробочка `tom`. Она ждет, когда мы положим что-то внутрь неё.

# * **Случай 1: `tom("pass_for_Tom")`**
#     Мы берем еще одну бумажку со словом `"pass_for_Tom"` и кладем её внутрь коробочки `tom`. Внутри коробочки `tom` эта бумажка временно называется `inner_arg`.

#     Маленькая коробочка смотрит на свою инструкцию: "Сравни `inner_arg` (`"pass_for_Tom"`) с `outer_arg` (она помнит, что это было `"pass_for_Tom"` от большой коробки)". Они одинаковые, поэтому коробочка `tom` выдает нам "Правда" (`True`).

# * **Случай 2: `tom("wrong_password")`**
#     Мы берем бумажку со словом `"wrong_password"` и кладем её внутрь коробочки `tom`. Внутри коробочки `tom` эта бумажка временно называется `inner_arg`.

#     Маленькая коробочка смотрит на свою инструкцию: "Сравни `inner_arg` (`"wrong_password"`) с `outer_arg` (она все еще помнит, что это было `"pass_for_Tom"` от большой коробки)". Они разные, поэтому коробочка `tom` выдает нам "Неправда" (`False`).

# **Аналогия с печеньем:**

# Представьте, что функция `create` - это фабрика формочек для печенья. Когда вы говорите `create("звездочка")`, фабрика создает формочку в виде звездочки и запоминает, что это была звездочка. Она отдает вам эту формочку.

# Теперь у вас есть формочка `tom` (в форме звездочки). Когда вы берете кусок теста и прикладываете к нему формочку `tom`, вы получаете печенье в форме звездочки.

# Аргумент `outer_arg` ("звездочка") - это форма, которую запомнила фабрика при создании формочки.

# Аргумент `inner_arg` (кусок теста) - это то, что вы даете самой формочке, чтобы получить результат (печенье).

# Функция `tom` (сама формочка) "знает", какая форма была использована при её создании ("звездочка") и сравнивает её с "формой" того, что вы ей дали (например, если вы попытаетесь "вырезать" круг из теста формочкой-звездочкой, результат будет зависеть от того, что вы ожидаете). В нашем случае, сравнение происходит на уровне текста.

# Надеюсь, эти аналогии помогут вам лучше понять, как `inner_arg` получает свое значение при вызове возвращенной лямбда-функции. Главное помнить, что `create` создает функцию, а мы передаем аргумент этой созданной функции позже, при её вызове.