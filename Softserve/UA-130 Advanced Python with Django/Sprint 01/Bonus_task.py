# Goal
# To consolidate work with arrays, nested loops, conditions, finding the maximum, and limiting cases.

# Task
# Implement a function that returns the maximum sum of a continuous subarray whose length does not exceed k.

# There is a list of integers a (can contain both positive and negative values) and an integer k. Find the maximum possible sum of a subarray of length at most k, which consists of continuous elements.

# Example:

# Input: a = [1, -2, 3, 4, -1, 2], k = 3
# Output: 7
# Explanation: The subarray [3, 4] has a sum of 7, and length 2 ≤ 3.
# What is tested:

# knowledge of algorithms for summation (prefix sum / sliding window);
# complex conditions in loops;
# limit control and comparison of options;
# attentiveness to extreme cases.

# Problem statement
# The input is a list of integers (can be both positive and negative).
# You need to find the maximum sum of a continuous subarray with a length from 1 to k inclusive.
# If the list is empty or k < 1, return 0.

# Цель
# Закрепить навыки работы с массивами, вложенными циклами, условиями, поиском максимального значения и контролем граничных случаев.
# Задача
# Реализовать функцию, которая возвращает максимальную сумму непрерывного подмассива, длина которого не превышает k.
# Есть список целых чисел a (может содержать как положительные, так и отрицательные значения) и целое число k. Нужно найти максимально возможную сумму подмассива длиной не более k, состоящего из непрерывных элементов.
# Пример
# Вход: a = [1, -2, 3, 4, -1, 2], k = 3
# Выход: 7
# Объяснение: Подмассив [3, 4] имеет сумму 7, а его длина 2 ≤ 3.
# Что проверяется в решении:
# ✅ Знание алгоритмов для суммирования (префиксная сумма / скользящее окно)
# ✅ Сложные условия в циклах
# ✅ Контроль граничных случаев и сравнение возможных вариантов
# ✅ Внимательность к экстремальным ситуациям
# Формулировка проблемы:
# Входные данные — список целых чисел (могут быть как положительными, так и отрицательными).
# Нужно найти максимальную сумму непрерывного подмассива длиной от 1 до k включительно.
# Если список пуст или k < 1, вернуть 0.

def max_subarray_sum_limited(a, k):
    if not a or k < 1:
        return 0
    
    max_sum = float('-inf')
    
    # Перебираем возможные длины подмассива от 1 до k
    for length in range(1, k + 1):
        current_sum = sum(a[:length])  # Начальная сумма подмассива
        max_sum = max(max_sum, current_sum)

        # Используем скользящее окно для обновления суммы
        for i in range(length, len(a)):
            current_sum += a[i] - a[i - length]
            max_sum = max(max_sum, current_sum)
    
    return max_sum

# Пример использования:
a = [1, -2, 3, 4, -1, 2]
k = 3
print(max_subarray_sum_limited(a, k))  # Output: 7
Давай разберём задачу максимально просто и пошагово.

---

### **Что нам дано:**

1. **Массив чисел (`a`):** Это список целых чисел, в котором могут быть как положительные, так и отрицательные значения. Например, `[1, -2, 3, 4, -1, 2]`.
2. **Целое число `k`:** Ограничение на максимальную длину подмассива. То есть, мы ищем последовательные элементы, от 1 до `k` штук.

---

### **Что нужно сделать:**

# Нужно найти такой непрерывный подмассив из чисел (последовательный фрагмент массива), длина которого не превышает `k`, и у которого сумма элементов самая большая среди всех возможных подмассивов с длиной от 1 до `k`.

# Если массив пустой или `k` меньше 1, функция должна вернуть 0.

# ---

# ### **Пошаговое решение:**

# 1. **Проверка на крайние случаи:**
#    - Если массив пуст (`a` пустой) или число `k` меньше 1, сразу возвращаем 0.
  
# 2. **Перебор возможных длин подмассива:**
#    - Подумай так: допустим, `k` равно 3. Это значит, мы можем брать подмассивы длиной 1, 2 или 3.
#    - Для каждой такой длины будем искать максимальную сумму подмассива.

# 3. **Рассмотрим подмассивы фиксированной длины:**
#    - Допустим, рассматриваем длину `L` (где `1 ≤ L ≤ k`).
#    - Сначала считаем сумму первых `L` элементов (это первая «окошко»).
#    - Эта сумма станет нашей начальной "максимальной" значением для этой длины.
  
# 4. **Скользящее окно (Sliding Window):**
#    - Теперь, чтобы не пересчитывать сумму каждый раз с нуля, используем метод «скользящего окна».
#    - Представь, что окно длиной `L` двигается по массиву. Если мы знаем сумму чисел в окне, то, чтобы получить сумму следующего окна, нужно вычесть элемент, который вышел из окна (самый левый) и прибавить следующий элемент справа.
#    - Таким образом, для каждого нового окна обновляем сумму и сравниваем её с текущим максимальным значением для подмассива длиной `L`. Если сумма больше – обновляем максимум.
  
# 5. **Обновление общего максимума:**
#    - Для каждой длины (от 1 до `k`) мы получаем своё максимальное значение суммы.
#    - После перебора всех длин выбираем самое большое значение из всех найденных.

# 6. **Возврат результата:**
#    - В конце возвращаем общее максимальное значение суммы, которое получилось среди всех подмассивов с длиной от 1 до `k`.

# ---

# ### **Пошаговый пример на массиве `[1, -2, 3, 4, -1, 2]` и `k = 3`:**

# 1. **Длина 1:**  
#    - Проверяем все одиночные числа: 1, -2, 3, 4, -1, 2.  
#    - Максимум = 4.

# 2. **Длина 2:**  
#    - Посмотрим пары:  
#      - `[1, -2]` → 1 + (-2) = -1  
#      - `[-2, 3]` → -2 + 3 = 1  
#      - `[3, 4]` → 3 + 4 = 7  
#      - `[4, -1]` → 4 + (-1) = 3  
#      - `[-1, 2]` → -1 + 2 = 1  
#    - Максимум для длины 2 = 7.

# 3. **Длина 3:**  
#    - Посмотрим подмассивы длиной 3:  
#      - `[1, -2, 3]` → 1 - 2 + 3 = 2  
#      - `[-2, 3, 4]` → -2 + 3 + 4 = 5  
#      - `[3, 4, -1]` → 3 + 4 - 1 = 6  
#      - `[4, -1, 2]` → 4 - 1 + 2 = 5  
#    - Максимум для длины 3 = 6.

# 4. **Общий максимум:**  
#    - Среди всех полученных максимумов (4 для длины 1, 7 для длины 2, 6 для длины 3) самым большим является 7.

# ---

# ### **Заключение:**

# Таким образом, максимальная сумма непрерывного подмассива с длиной, не превышающей `k` (3 в примере), равна **7**.

# Надеюсь, такое подробное и пошаговое объяснение помогло тебе лучше понять задачу! Если что-то осталось неясным — спрашивай.