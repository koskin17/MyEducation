# For the given integer n, consider an increasing sequence consisting of all positive integers that are either powers of n, or sums of distinct powers of n.
# Your task is to find the kth (1-based) number in this sequence.
# Example
# For n = 3 and k = 4, the output should be
# kthTerm(n, k) = 9.
# For n = 3, the sequence described above begins as follows: 1, 3, 4, 9, 10, 12, 13...
# [3**0] => [1]
# [1, 3**1, 3**1 +1] => [1, 3, 4]
# [1, 3, 4, 3**2, 3**2 +1, 3**2 +3, 3**2 +4] => [1, 3, 4, 9, 10, 12, 13]
# ...
# The 4th number in this sequence is 9, which is the answer.
# Input/Output
# [input] integer n
# The number to build the sequence by.
# Constraints:
# 2 ≤ n ≤ 30.
# [input] integer k
# The 1-based index of the number in the sequence.
# Constraints:
# 1 ≤ k ≤ 100.
# [output] integer
# The kth element of the sequence.

def kthTerm(n, k):
    # Получим двоичное представление числа k без префикса "0b"
    binary = bin(k)[2:]
    result = 0
    length = len(binary)
    
    # Для каждой цифры в двоичной строке
    # Цифры идут слева направо, старший разряд соответствует наибольшей степени
    for i, digit in enumerate(binary):
        if digit == '1':
            # Позиция i (слева направо) соответствует степени (length-i-1)
            result += n ** (length - i - 1)
    return result

# Проверка на примере:
print(kthTerm(3, 4))  # Вывод: 9

# Решение использует преобразование числа `k` в двоичный формат, чтобы воспользоваться естественным соответствием между двоичным представлением и суммами различных степеней числа `n`. Давайте разберём, почему это работает, шаг за шагом:

# 1. **Суть последовательности:**  
#    Последовательность состоит из всех положительных чисел, которые можно получить как сумму различных степеней числа `n` (то есть \( n^0, n^1, n^2, \dots \)). Каждый элемент этой последовательности — это сумма, где каждая степень либо включена (соответствующий коэффициент равен 1), либо нет (коэффициент равен 0).

# 2. **Соответствие двоичному представлению:**  
#    Если у вас есть набор степеней, то решение «включить» или «не включить» каждую из них можно представить в виде двоичного числа:  
#    - Цифра 1 означает, что соответствующая степень входит в сумму.  
#    - Цифра 0 означает, что соответствующая степень не входит в сумму.

#    Таким образом, каждая сумма из последовательности соответствует некоему двоичному числу, где само число складывается по формуле:  
#    \[
#    \text{результат} = b_m \times n^m + b_{m-1} \times n^{m-1} + \dots + b_0 \times n^0,
#    \]
#    где \(b_i\) равны 0 или 1.

# 3. **Почему берём именно двоичное представление числа `k`:**  
#    Если мы упорядочим все такие суммы по возрастанию, то можно заметить, что позиция (1-based) элемента совпадает с двоичным представлением определённого числа. Другими словами, чтобы найти **k**-й элемент в последовательности, можно представить число `k` в двоичном формате и «подставить» его цифры как индикаторы включения степеней числа `n`.  
   
#    Например, для n = 3 и k = 4:  
#    - Двоичное представление числа 4: `"100"`.  
#    - Это означает, что включается степень с номером \(2\) (так как длина строки 3, и самая левая цифра соответствует \(n^{2}\)), а остальные степени не включаются.  
#    - Вычисление: \(3^2 = 9\), что и есть ожидаемый результат.

# 4. **Реализация в коде:**  
#    - Функция `bin(k)[2:]` преобразует число `k` в строку двоичного представления без префикса `"0b"`.  
#    - Затем, проходясь по каждой цифре этой строки, мы проверяем, равна ли она `'1'`. Если да, то добавляем к результату соответствующую степень числа `n`.  
#    - Порядок обхода определяется длиной двоичной строки: самый левый символ соответствует наивысшей степени \( n^{(\text{length}-1)} \), следующий — \( n^{(\text{length}-2)} \) и так далее.

# Таким образом, преобразование `k` в двоичный формат позволяет легко и эффективно выбрать, какие степени числа `n` добавить, чтобы получить **k**-й элемент описанной последовательности.

# Если возникнут дополнительные вопросы или потребуется подробное объяснение какого-либо этапа — спрашивай!